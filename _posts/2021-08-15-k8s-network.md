---
title: K8s 的网络
key: 2021-08-15
tags: kubernetes k8s network
---

## Kubernetes 的网络模型

Container Network Interface (CNI) 容器网络接口，由 Google 和 CoreOS 主导。是由 CoreOS 提出的一个容器网络规范。已采纳规范的包括 Apache Mesos，Cloud Foundry，Kubernetes，Kurma 和 RKT。

K8s 网络模型设计的级别要求是：

- 一个 Pod 一个 IP。
- 每个 Pod 独立 IP， Pod 内所有容器共享网络 （同一个 IP）。
- 所有容器都可以与其他容器通信。
- 所有结点都可以与其他容器通信。

简而言之，所有 IP 都是可以通信的。

所有容器之间无需 NAT 就可以直接互相访问；所有 Node 和所有容器之间无需 NAT 就可以直接互相访；容器自己看到的 IP 跟其他容器看到的一样。

## K8S 网络规范

CNI 规定了一个容器 Runtime 和网络插件之间的简单的契约。这个契约通过 JSON 的语法定义了 CNI 插件所需要提供的输入和输出。

CNI 插件提供两个功能：

- 一个用来将网络接口加入到指定网络。
- 另一个用来将其移除。

这两个接口分别在容器被创建和销毁的时候被调用。容器 Runtime 首先需要获得一个网络命名空间以及一个容器 ID，然后连同一些 CNI 配置参数传给网络驱动。

接着网络驱动会将该容器连接到网络并将分配的 IP 地址以 JSON 的格式返回给容器 Runtime。

## K8S 网络插件要求

K8S 对网络插件的要求总的来讲主要有两个最基本的，分别是：

- 要能够为每一个 Node 上的 Pod 分配互相不冲突的 IP 地址。
- 要所有 Pod 之间能够互相访问。

## K8S 网络实现方案

K8S网络实现方案有如下几种：

### 隧道方案

隧道方案在 IaaS 层的网络中应用也比较多，将 Pod 分布在一个大二层的网络规模下。网络拓扑简单，但随着节点规模的增长复杂度会提升。

代表方案：

- Weave：UDP 广播，本机建立新的 BR，通过 PCAP 互通。
- Open vSwitch：基于 VxLan 和 GRE 协议，但是性能方面损失比较严重。
- Flannel：UDP 广播，VxLan。
- Racher：IPsec。

### 路由方案

路由方案一般是从 3 层或者 2 层实现隔离和跨主机容器互通的，出了问题也很容易排查。

代表方案：

- Calico：基于 BGP 协议的路由方案，支持很细致的 ACL 控制，对混合云亲和度比较高。
- Macvlan：从逻辑和 Kernel 层来看隔离性和性能优的方案，基于二层隔离，所以需要二层路由器支持，大多数云服务商不支持，所以混合云上比较难以实现。

## K8S Pod 的网络创建流程

K8S Pod 的网络创建流程如下：

- 每个 Pod 除了创建时指定的容器外，都有一个 Kubelet 启动时指定的基础容器。
- Kubelet 创建基础容器，生成 Network Namespace。
- Kubelet 调用网络 CNIdriver，根据配置调用具体的 CNI 插件。
- CNI 插件给基础容器配置网络。
- Pod 中其他的容器共享基础容器的网络。

## Pod 中的网络

Pod 是 K8S 的最小工作单元。每个 Pod 包含一个或多个容器。K8S 管理的也是 Pod 而不是直接管理容器。Pod 中的容器会作为一个整体被 Master 调度到一个 Node 上运行。

Pod 的设计理念是支持多个容器在一个 Pod 中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。

一个 Pod 中可以包含多个容器，而一个 Pod 只有一个 IP 地址。那么多个容器之间互相访问和访问外网是如何使用这一个 IP 地址呢?

答案是：多个容器共享同一个底层的网络命名空间 Net (网络设备、网络栈、端口等)。

下面以一个小例子说明，创建一个 Pod 包含两个容器，yaml 文件如下：

```yaml
apiVersion: apps/v1beta1 
kind: Deployment 
metadata: 
  name: Pod-two-container 
spec: 
  replicas: 1 
  template: 
    metadata: 
      labels: 
        app: nginx 
    spec: 
      containers: 
      - name: busybox 
        image: busybox 
        command: 
        - "/bin/sh" 
        - "-c" 
        - "while true;do echo hello;sleep 1;done" 
      - name: nginx 
        image: nginx 
```

## CentOS7安装Kubernetes1.18.1并使用flannel

原文: [https://www.cnblogs.com/xiao987334176/p/12696740.html](https://www.cnblogs.com/xiao987334176/p/12696740.html)

手工搭建 Kubernetes 集群是一件很繁琐的事情，为了简化这些操作，就产生了很多安装配置工具，如 Kubeadm ，Kubespray，RKE 等组件，我最终选择了官方的 Kubeadm 主要是不同的 Kubernetes 版本都有一些差异，Kubeadm 更新与支持的会好一些。Kubeadm 是 Kubernetes 官方提供的快速安装和初始化 Kubernetes 集群的工具，目前的还处于孵化开发状态，跟随 Kubernetes 每个新版本的发布都会同步更新, 强烈建议先看下官方的文档了解下各个组件与对象的作用。

https://kubernetes.io/docs/concepts/
https://kubernetes.io/docs/setup/independent/install-kubeadm/
https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/

在创建Kubernetes集群时，阿里云容器服务提供两种网络插件：Terway和Flannel。

Flannel：使用的是简单稳定的社区的Flannel CNI 插件，配合阿里云的VPC的高速网络，能给集群高性能和稳定的容器网络体验，但功能偏简单，支持的特性少，例如：不支持基于Kubernetes标准的Network Policy。
Terway：是阿里云容器服务自研的网络插件，将阿里云的弹性网卡分配给容器，支持基于Kubernetes标准的NetworkPolicy来定义容器间的访问策略，支持对单个容器做带宽的限流。对于不需要使用Network Policy的用户，可以选择Flannel，其他情况建议选择Terway。

因此，本文主要介绍flannel的简单使用。

## 准备工作

> **注意** 必须在所有机器上执行

### 关闭防火墙

如果各个主机启用了防火墙，需要开放Kubernetes各个组件所需要的端口，可以查看Installing kubeadm中的”Check required ports”一节。 这里简单起见在各节点禁用防火墙：

```bash
systemctl stop firewalld
systemctl disable firewalld
```

### 禁用SELINUX

```bash
# 临时禁用
setenforce 0
# 永久禁用 
vim /etc/selinux/config    # 或者修改/etc/sysconfig/selinux
SELINUX=disabled
```

### 系统配置

```bash
cd /etc/sysctl.d/

cat <<EOF >  /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF

sysctl --system

```

### 开启路由转发

```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
```

### 关闭swap

```bash
# 临时关闭
swapoff -a

# 修改 /etc/fstab 文件，注释掉 SWAP 的自动挂载（永久关闭swap，重启后生效）
# 注释掉以下字段
/dev/mapper/cl-swap     swap                    swap    defaults        0 0
```

### 安装docker

略...

### 修改主机名

```bash
hostnamectl set-hostname k8s-master
```

注意：主机名不能带下划线，只能带中划线
否则安装k8s会报错

> could not convert cfg to an internal cfg: nodeRegistration.name: Invalid value: "k8s_master": a DNS-1123 subdomain must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character (e.g. 'example.com', regex used for validation is '[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*')

## 安装 kubeadm, kubelet, kubectl

### 修改 yum 安装源

```bash

sudo -i
cd /etc/yum.repos.d/
touch kubernetes.repo

cat <<EOF > /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF

yum -y install kubelet kubeadm kubectl 
systemctl enable kubelet && systemctl start kubelet

systemctl disable kubelet && systemctl stop kubelet
yum -y remove kubelet kubeadm kubectl 

## 此时只能安装 1.18.1, 
## 以为其他的版本, 就下载不下来相关的组件了.
## 所以前的安装的又特么的删掉了.
yum install -y kubelet-1.18.1-0 kubeadm-1.18.1-0 kubectl-1.18.1-0
systemctl enable kubelet && systemctl start kubelet

```

### 运行初始化命令

```bash
kubeadm init --kubernetes-version=1.18.1 \
--apiserver-advertise-address=10.10.10.241 \
--image-repository registry.aliyuncs.com/google_containers \
--service-cidr=10.1.0.0/16 \
--pod-network-cidr=10.244.0.0/16
```

注意**修改 apiserver-advertise-address 为 master 节点 ip**

参数解释：

```sh
–kubernetes-version: 用于指定k8s版本；
–apiserver-advertise-address：用于指定kube-apiserver监听的ip地址,就是 master本机IP地址。
–pod-network-cidr：用于指定Pod的网络范围； 10.244.0.0/16
–service-cidr：用于指定SVC的网络范围；
–image-repository: 指定阿里云镜像仓库地址
```

这一步很关键，由于kubeadm 默认从官网k8s.grc.io下载所需镜像，国内无法访问，因此需要通过–image-repository指定阿里云镜像仓库地址

集群初始化成功后返回如下信息：
记录生成的最后部分内容，此内容需要在其它节点加入Kubernetes集群时执行。
输出如下：

```sh
....

Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 10.10.10.241:6443 --token io1pa7.pp3wbn8i4hbi7ktn \
    --discovery-token-ca-cert-hash sha256:e9dd69f71312e61280d6d3a257f811135b43dea7e62fd667478bb776af16737d

```

注意: **保存好上面的信息**

### 配置kubectl工具

```bash
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
```

### 安装flannel

```bash
mkdir k8s
cd k8s
wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
```

如果yml中的"Network": "10.244.0.0/16"和kubeadm init xxx --pod-network-cidr不一样，就需要修改成一样的。不然可能会使得Node间Cluster IP不通。

由于我上面的kubeadm init xxx --pod-network-cidr就是10.244.0.0/16。所以此yaml文件就不需要更改了。

### 获取镜像

查看 yaml 需要的镜像

```bash
cat kube-flannel.yml |grep image|uniq
        image: quay.io/coreos/flannel:v0.14.0
```

现在是 14.0 的版本了, 原文说去阿里云的 ACR 中下载, 但是 ACR 中没找到, 然后我去 docker hub 上找到了一个...

```bash
docker login
chengchao

docker pull xwjh/flannel:v0.14.0
docker tag xwjh/flannel:v0.14.0  quay.io/coreos/flannel:v0.14.0

docker tag xwjh/flannel:v0.14.0 chengchao/flannel:v0.14.0
docker push chengchao/flannel:v0.14.0

```

#### 加载flannel

```bash
kubectl apply -f kube-flannel.yml
```

### 设置开机启动

```bash
systemctl enable kubelet
```

安装命令补全:

```bash
yum install -y bash-completion

source < $(kubectl completion bash)
echo "source <(kubectl completion bash)" >> ~/.bashrc
source  ~/.bashrc
```

## node 加入集群

执行上面的 kubeadm join 命令

设置开机启动:

```bash
systemctl enable kubelet
```

查看:

```bash
kubectl get nodes  -o wide
```

EOF
